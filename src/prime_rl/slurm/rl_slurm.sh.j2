#!/bin/bash

#SBATCH --job-name={{ job_name }}
#SBATCH --nodes={{ num_train_nodes + num_infer_nodes }}
#SBATCH --ntasks-per-node=1
#SBATCH --gres=gpu:{{ gpus_per_node }}
#SBATCH --partition=cluster
#SBATCH --exclusive                 # Get the ENTIRE node exclusively
#SBATCH --output=/shared/logs/job_%j.log
#SBATCH --error=/shared/logs/job_%j.log

# Dump a traceback on SIGABRT / SIGSEGV
export PYTHONFAULTHANDLER=1

# Configs
export NUM_TRAIN_NODES={{ num_train_nodes }}
export NUM_INFER_NODES={{ num_infer_nodes }}
export GPUS_PER_NODE={{ gpus_per_node }}

# Paths
export PROJECT_DIR={{ project_dir }}
export CONFIG_DIR={{ config_dir }}
export OUTPUT_DIR={{ output_dir }}
export ORCHESTRATOR_OUTPUT_DIR={{ orchestrator_output_dir }}
mkdir -p $OUTPUT_DIR/slurm

# Clear previous rollouts and broadcast flags from ALL runs (not just the current one)
# to prevent the trainer from training on stale data from old run_* directories.
# WARN: This is potentially dangerous and could lead to data loss
rm -rf $OUTPUT_DIR/run_*/rollouts
rm -rf $OUTPUT_DIR/run_*/broadcasts
rm -rf $OUTPUT_DIR/rollouts

# General
export CUDA_DEVICE_ORDER=PCI_BUS_ID
export PYTHONUNBUFFERED=1
export OMP_NUM_THREADS=1

# Networking
export HOSTNAMES=( $( scontrol show hostnames $SLURM_JOB_NODELIST ) )
export INFER_HOSTS=${HOSTNAMES[@]:0:$NUM_INFER_NODES}
export TRAIN_HOSTS=${HOSTNAMES[@]:$NUM_INFER_NODES:$SLURM_JOB_NUM_NODES}

INFER_URLS=""
for host in ${INFER_HOSTS[@]}; do
    if [ -z "$INFER_URLS" ]; then
        INFER_URLS="http://$host:8000/v1"
    else
        INFER_URLS="$INFER_URLS,http://$host:8000/v1"
    fi
done
export INFER_URLS
echo "HOSTNAMES=${HOSTNAMES[@]}"
echo "TRAIN_HOSTS=${TRAIN_HOSTS[@]}"
echo "INFER_HOSTS=${INFER_HOSTS[@]}"
echo "INFER_URLS=${INFER_URLS}"

export MASTER_ADDR="${HOSTNAMES[$NUM_INFER_NODES]}"
export MASTER_PORT=29500
echo "MASTER_ADDR=${MASTER_ADDR}"
echo "MASTER_PORT=${MASTER_PORT}"

# Kill stale processes from previous runs
srun bash -c 'pkill -9 -f torchrun || true && fuser -k ${MASTER_PORT}/tcp || true'
srun bash -c 'pkill -9 -f prime-rl || true'
srun bash -c 'pkill -9 -f VLLM || true && fuser -k 8000/tcp || true'

# Install environment
[ -f $PROJECT_DIR/.env ] && source $PROJECT_DIR/.env
source $PROJECT_DIR/.venv/bin/activate

# Install environment as local package
cd $PROJECT_DIR && uv sync --all-extras


# Run RL
srun bash -c '
    # Setup environment
    [ -f $PROJECT_DIR/.env ] && source $PROJECT_DIR/.env
    source $PROJECT_DIR/.venv/bin/activate

    # Disable sync to avoid conflicts with lockfile

    # Higher ulimit
    ulimit -n 65536
    export GIT_LFS_SKIP_SMUDGE=1

    # Infiniband setup
    IB_HCA=$(ibv_devinfo | sed -n -e "/hca_id/p" -e "/link_layer:/p" | grep -B1 InfiniBand | grep hca_id | sed -e "s/^hca_id://g" | tr -d "[[:blank:]]" |paste -sd,)
    export NCCL_IB_HCA=$IB_HCA

if [ "$SLURM_PROCID" -lt "$NUM_INFER_NODES" ]; then
{% if hf_hub_offline %}
    export HF_HUB_OFFLINE=1
    export TRANSFORMERS_OFFLINE=1
    export HF_DATASETS_OFFLINE=1
{% endif %}

    # This is required for vLLM graph compile to work
    export PYTORCH_CUDA_ALLOC_CONF="expandable_segments:False"
    INFER_NODE_RANK=$SLURM_PROCID
    export VLLM_WORKER_MULTIPROC_METHOD=spawn

    uv run inference \
        @ $CONFIG_DIR/inference.toml \
        --enable-auto-tool-choice \
        --enable-log-requests \
        --no-disable-log-requests \
        2>&1 | tee $OUTPUT_DIR/slurm/latest_infer_node_rank_${INFER_NODE_RANK}.log $OUTPUT_DIR/slurm/job_${INFER_NODE_RANK}_infer_node_rank_${INFER_NODE_RANK}.log
else
    TRAIN_NODE_RANK=$((SLURM_PROCID - NUM_INFER_NODES))

    if [ "$TRAIN_NODE_RANK" -eq 0 ]; then
        uv run orchestrator \
            @ $CONFIG_DIR/orchestrator.toml \
            --weight_broadcast.host $MASTER_ADDR \
            --client.base-url $INFER_URLS \
            ${BETTER_STACK_URL_ORCH:+--heartbeat.url $BETTER_STACK_URL_ORCH} \
            2>&1 | tee $OUTPUT_DIR/slurm/latest_orchestrator.log $OUTPUT_DIR/slurm/job_${SLURM_JOB_ID}_orchestrator.log & disown
    fi

    export HF_HUB_OFFLINE={{ 1 if hf_hub_offline else 0 }}
{% if hf_hub_offline %}
    export TRANSFORMERS_OFFLINE=1
    export HF_DATASETS_OFFLINE=1
{% endif %}

    # This is required for compilation to work correctly
    export PYTORCH_CUDA_ALLOC_CONF="expandable_segments:True"

        echo $HOSTNAMES | tee  $OUTPUT_DIR/slurm/latest_train_node_rank_${TRAIN_NODE_RANK}.log
    uv run torchrun \
        --nnodes=$NUM_TRAIN_NODES \
        --nproc-per-node=$GPUS_PER_NODE \
        --node-rank=$TRAIN_NODE_RANK \
        --rdzv-endpoint=$MASTER_ADDR:$MASTER_PORT \
        --rdzv-id=job_$SLURM_JOB_ID \
        --log-dir=$OUTPUT_DIR/torchrun \
        --tee=3 \
        --redirects=3 \
        --local-ranks-filter=$(seq -s, 0 $((GPUS_PER_NODE - 1))) \
        -m prime_rl.trainer.rl.train \
        @ $CONFIG_DIR/trainer.toml \
        2>&1 | tee -a $OUTPUT_DIR/slurm/latest_train_node_rank_${TRAIN_NODE_RANK}.log $OUTPUT_DIR/slurm/job_${SLURM_JOB_ID}_train_node_rank_${TRAIN_NODE_RANK}.log
    fi
'
